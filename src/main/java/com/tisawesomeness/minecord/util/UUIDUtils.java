package com.tisawesomeness.minecord.util;

import lombok.NonNull;

import java.util.Optional;
import java.util.UUID;
import java.util.regex.Pattern;

/**
 * Utility class to work with {@link UUID} and UUID strings with or without dashes
 */
public final class UUIDUtils {
    private UUIDUtils() {}

    // Minecraft uses Version 4, Variant 1 UUIDs (the kind generated by UUID.randomUUID())
    private static final int UUID_LENGTH = 32;
    private static final Pattern SHORT_UUID_PATTERN = Pattern.compile(
            "^([0-9a-fA-F]{8})([0-9a-fA-F]{4})(4[0-9a-fA-F]{3})([89abAB][0-9a-fA-F]{3})([0-9a-fA-F]{12})$");
    private static final Pattern EFFICIENT_SHORT_UUID_PATTERN = Pattern.compile(
            "^(.{8})(.{4})(.{4})(.{4})(.{12})$");
    private static final String SHORT_UUID_REPLACEMENT = "$1-$2-$3-$4-$5";
    private static final Pattern LONG_UUID_PATTERN = Pattern.compile(
            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$");

    /**
     * Tries to parse a version 4, variant 1 UUID from a string.
     * <br>A valid UUID is in the format {@code xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx},
     * case insensitive and with or without dashes.
     * <br>{@code M} = the version of the UUID, which is 4.
     * <br>{@code N} = the upper bits encode the variant of the UUID, 8-b means variant 1.
     * @param str A possible UUID string
     * @return The parsed UUID or empty if the string is not the correct format
     */
    public static Optional<UUID> fromString(@NonNull String str) {
        if (LONG_UUID_PATTERN.matcher(str).matches()) {
            return Optional.of(UUID.fromString(str));
        }
        String replaced = SHORT_UUID_PATTERN.matcher(str).replaceFirst(SHORT_UUID_REPLACEMENT);
        if (!replaced.equals(str)) {
            return Optional.of(UUID.fromString(replaced));
        }
        return Optional.empty();
    }

    /**
     * Efficiently converts a short UUID to a UUID object by skipping regex validation.
     * <br>This does not enforce the correct UUID version and variant.
     * @param str <b>Must be a valid short UUID!</b>
     * @return A UUID object
     * @throws IllegalArgumentException if the input string is not a valid short UUID
     */
    public static @NonNull UUID fromGuarenteedShortString(@NonNull CharSequence str) {
        if (str.length() != UUID_LENGTH) {
            throw new IllegalArgumentException("A short UUID must be exactly 32 characters.");
        }
        String r = EFFICIENT_SHORT_UUID_PATTERN.matcher(str).replaceFirst(SHORT_UUID_REPLACEMENT);
        return UUID.fromString(r);
    }

    /**
     * Converts a UUID to a string without dashes.
     * @param uuid Any input UUID
     * @return The UUID as a string
     */
    public static @NonNull String toShortString(@NonNull UUID uuid) {
        return uuid.toString().replace("-", "");
    }

    /**
     * Converts a UUID to a string with dashes in {@code 8-4-4-4-12} format.
     * @param uuid Any input UUID
     * @return The UUID as a string
     */
    public static @NonNull String toLongString(@NonNull UUID uuid) {
        return uuid.toString();
    }

    /**
     * Converts a UUID to pre-1.16 UUIDMost/UUIDLeast NBT.
     * @param uuid The UUID
     * @return UUIDMost,UUIDLeast
     */
    public static @NonNull String toMostLeastString(@NonNull UUID uuid) {
        return String.format("UUIDMost:%d,UUIDLeast:%d", uuid.getMostSignificantBits(), uuid.getLeastSignificantBits());
    }

    /**
     * Converts a UUID to an 1.16+ NBT int array string.
     * @param uuid The UUID
     * @return The NBT int array as a string
     */
    public static @NonNull String toIntArrayString(@NonNull UUID uuid) {
        int[] arr = toIntArray(uuid);
        return String.format("[I;%d,%d,%d,%d]", arr[0], arr[1], arr[2], arr[3]);
    }
    /**
     * Converts a UUID to an array of four ints, most to least significant, used in 1.16+ NBT.
     * @param uuid The UUID
     * @return An array of four ints
     */
    public static int[] toIntArray(@NonNull UUID uuid) {
        int[] arr = new int[4];
        long msb = uuid.getMostSignificantBits();
        arr[0] = (int) (msb >> 32);
        arr[1] = (int) msb;
        long lsb = uuid.getLeastSignificantBits();
        arr[2] = (int) (lsb >> 32);
        arr[3] = (int) lsb;
        return arr;
    }

}
